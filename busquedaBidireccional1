
# * Representado a traves de un diccionario de {vertices : listas}
ejemplo1 = {0:[1,2], 1:[0,3,4], 3:[1], 4:[1], 2:[0,5,6], 5:[2], 6:[2]}


def busquedaBidireccional1(arbol, inicio, meta):
    # * Revisamos si el inicio y el final son iguales.
    if inicio == meta:
        return [inicio]
    # * Obtenemos el diccionario de los vertices activos actualmente con sus correspondientes caminos.
    dicc_caminos_vertices_activos = {inicio: [inicio], meta: [meta]}
    # * Vertices que ya hemos verificado.
    vertices_inactivos = set()

    while len(dicc_caminos_vertices_activos) > 0:

        # * Hace una copia de los vertices para poder modificar el diccionario en el trayecto.
        vertices_activos = list(dicc_caminos_vertices_activos.keys())
        for vertice in vertices_activos:
            # * Obtiene el camino hacia donde estamos actualmente.
            camino_actual = dicc_caminos_vertices_activos[vertice]
            # * Guarda si empezamos en el inicio o en el final.
            origen = camino_actual[0]
            # * Verifica nuevos hermanos
            hermanos_actuales = set(arbol[vertice]) - vertices_inactivos
            # * Verifica si nuestros hermanos tienen algun vertice activo
            if len(hermanos_actuales.intersection(vertices_activos)) > 0:
                for vertice_encuentro in hermanos_actuales.intersection(vertices_activos):
                    # * Verifica que los dos caminos no hayan iniciado en el mismo sitio.
                    # * Si no, tenemos un camino desde el inicio hasta el final.
                    if origen != dicc_caminos_vertices_activos[vertice_encuentro][0]:
                        # * Invierte uno de los caminos.
                        dicc_caminos_vertices_activos[vertice_encuentro].reverse()
                        # * Retorna los caminos combinados en uno solo
                        return dicc_caminos_vertices_activos[vertice] + dicc_caminos_vertices_activos[vertice_encuentro]

            # * Ninguno de los hermanos tiene un vertice activo, entonces
            # * verifica si hay nuevos hermanos para extender los caminos.
            if len(set(hermanos_actuales) - vertices_inactivos - set(vertices_activos))  == 0:
                # * Si no hay, entonces elimina el camino actual y guarda el punto de terminacio
                # * como inactivo.
                dicc_caminos_vertices_activos.pop(vertice, None)
                vertices_inactivos.add(vertice)
            else:
                # * en cualquier otro caso, extiende los caminos, remueve los caminos previos
                # * y actualiza los vertices inactivos.
                for vertice_hermano in hermanos_actuales - vertices_inactivos - set(vertices_activos):
                    dicc_caminos_vertices_activos[vertice_hermano] = camino_actual + [vertice_hermano]
                    vertices_activos.append(vertice_hermano)
                dicc_caminos_vertices_activos.pop(vertice, None)
                vertices_inactivos.add(vertice)

    return None

"""
El codigo se inicia a travez de una lista de vertices actualmente activos, empezando desde los vertices 
inicio y meta especificados,y va a traves de ellos con diccionario tal {vertices : listas}.
Si un nodo activo se encuentra a si mismo junto a otro nodo activo con un camino que haya iniciado desde el
el otro fin, combina las listas y retorna el resultado, en cualquier otro caso extiende todos los caminos y
continua con el resto.
"""

print(busquedaBidireccional1(ejemplo1,4, 6))
