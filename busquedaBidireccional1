
# * Representado a traves de un diccionario de {vertices : listas}
from cgi import print_arguments


""" 
EJ1
  0 1 2   
0     F   1 2 3
1   X X   4 5 6
2     I   7 8 9
                    key left right up down
                    evitando crear los nodos del que venimos (delvolverse)
                    
 
EJ2
  0 1 2 3                  
0       F     1  2  3  4             
1 X   X X     5  6  7  8
2             9  10 11 12
3       I     13 14 15 16
                    
"""

ejemplo1 = { 9:[8], 8:[9,7], 7:[8,4], 4:[7,1], 1:[4,2], 2:[1,3], 3:[2] }
ejemplo2 = { 16:[15,12], 15:[16, 14, 11], 12:[16], 14:[15, 13, 10], 11:[15], 13:[14,9], 10:[14, 6], 9:[13], 6:[10,2], 2:[6, 1, 3], 1:[2], 3:[2, 4], 4:[3]}


def busquedaBidireccional1(arbol, inicio, meta):
    # * Revisamos si el inicio y el final son iguales para descartar el caso trivial.
    if inicio == meta:
        return [inicio]
    # * Obtenemos el diccionario de los vertices activos actualmente con sus correspondientes caminos.
    dicc_caminos_vertices_activos = {inicio: [inicio], meta: [meta]}
    #print(dicc_caminos_vertices_activos)
    # * Vertices que ya hemos verificado.
    vertices_inactivos = set()


    # * Mientras que todavia hayan vertices activos, seguimos buscando.
    while len(dicc_caminos_vertices_activos) > 0:

        # * Hace una copia de los vertices para poder modificar el diccionario en el trayecto.
        vertices_activos = list(dicc_caminos_vertices_activos.keys())
        for vertice in vertices_activos:
            print(f" = vertices_activos {vertices_activos}")
            print(f" * vertices_inactivos {vertices_inactivos}")
            # * Obtiene el camino hacia donde estamos actualmente.
            camino_actual = dicc_caminos_vertices_activos[vertice]
            # * Guarda si empezamos en el inicio o en el final.
            origen = camino_actual[0]
            # * Verifica nuevos hermanos
            hermanos_actuales = set(arbol[vertice]) - vertices_inactivos
            print(f" + hermanos_actuales {hermanos_actuales}")
            # * Verifica si nuestros hermanos tienen algun vertice activo
            if len(hermanos_actuales.intersection(vertices_activos)) > 0:
                for vertice_encuentro in hermanos_actuales.intersection(vertices_activos):
                    # * Verifica que los dos caminos no hayan iniciado en el mismo sitio.
                    # * Si no, tenemos un camino desde el inicio hasta el final.
                    if origen != dicc_caminos_vertices_activos[vertice_encuentro][0]:
                        # * Invierte uno de los caminos.
                        dicc_caminos_vertices_activos[vertice_encuentro].reverse()
                        # * Retorna los caminos combinados en uno solo
                        return dicc_caminos_vertices_activos[vertice] + dicc_caminos_vertices_activos[vertice_encuentro]

            # * Ninguno de los hermanos tiene un vertice activo, entonces
            # * verifica si hay nuevos hermanos para extender los caminos.
            if len(set(hermanos_actuales) - vertices_inactivos - set(vertices_activos))  == 0:
                # * Si no hay, entonces elimina el camino actual y guarda el punto de terminacion
                # * como inactivo.
                dicc_caminos_vertices_activos.pop(vertice, None)
                vertices_inactivos.add(vertice)
            else:
                # * en cualquier otro caso, extiende los caminos, remueve los caminos previos
                # * y actualiza los vertices inactivos.
                for vertice_hermano in hermanos_actuales - vertices_inactivos - set(vertices_activos):
                    dicc_caminos_vertices_activos[vertice_hermano] = camino_actual + [vertice_hermano]
                    vertices_activos.append(vertice_hermano)
                dicc_caminos_vertices_activos.pop(vertice, None)
                vertices_inactivos.add(vertice)

    return None

"""
El codigo se inicia a travez de una lista de vertices actualmente activos, empezando desde los vertices 
inicio y meta especificados,y va a traves de ellos con diccionario tal {vertices : listas}.
Si un nodo activo se encuentra a si mismo junto a otro nodo activo con un camino que haya iniciado desde el
el otro fin, combina las listas y retorna el resultado, en cualquier otro caso extiende todos los caminos y
continua con el resto.
"""


#print(busquedaBidireccional1(ejemplo1, 3, 9))
print(busquedaBidireccional1(ejemplo2, 16, 4))

